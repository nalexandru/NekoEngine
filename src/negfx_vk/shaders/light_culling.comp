/* NekoEngine
 *
 * light_culling.comp
 * Author: Alexandru Naiman
 *
 * Light culling compute shader
 *
 * -----------------------------------------------------------------------------
 *
 * Copyright (c) 2015-2019, Alexandru Naiman
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors
 * may be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY ALEXANDRU NAIMAN "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL ALEXANDRU NAIMAN BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#version 460 core
#extension GL_GOOGLE_include_directive : require

// Based on:
// https://github.com/bcrusco/Forward-Plus-Renderer/blob/master/Forward-Plus/Forward-Plus/source/shaders/light_culling.comp.glsl

#define LIGHT_SET			0
#define LIGHT_BUFFER_BINDING		0
#define VISIBLE_INDICES_BINDING		1
#define VISIBLE_INDICES_WRITE		1

#define SCENE_DATA_SET			0
#define SCENE_DATA_BINDING		2

#include "scenedata.glh"
#include "light.glh"

layout(set = 0, binding = 3) uniform sampler2DMS depth_map;

shared uint min_depth_int;
shared uint max_depth_int;
shared vec4 frustum_planes[6];

shared uint visible_lights;
shared uint visible_indices[1024];

shared mat4 view_projection;
shared mat4 inverse_projection;

#define TILE_SIZE 16
layout(local_size_x = TILE_SIZE, local_size_y = TILE_SIZE, local_size_z = 1) in;

void
main()
{
	ivec2 location = ivec2(gl_GlobalInvocationID.xy);
	ivec2 item = ivec2(gl_LocalInvocationID.xy);
	ivec2 tile = ivec2(gl_WorkGroupID.xy);
	ivec2 tile_number = ivec2(gl_NumWorkGroups.xy);
	uint index = tile.y * tile_number.x + tile.x;

	if (gl_LocalInvocationIndex == 0) {
		min_depth_int = 0xFFFFFFFF;
		max_depth_int = 0;
		visible_lights = 0;
		view_projection = scene_data.proj * scene_data.view;
		inverse_projection = inverse(scene_data.proj);
	}

	barrier();

	float max_depth, min_depth;
	float depth = texelFetch(depth_map, location, 0).r;
	depth =  1.f / (depth * inverse_projection[2][3] + inverse_projection[3][3]);

	uint depth_int = floatBitsToUint(depth);
	atomicMin(min_depth_int, depth_int);
	atomicMax(max_depth_int, depth_int);

	barrier();

	if (gl_LocalInvocationIndex == 0) {
		min_depth = uintBitsToFloat(min_depth_int);
		max_depth = uintBitsToFloat(max_depth_int);

		vec2 negative_step = (2.0 * vec2(tile)) / vec2(tile_number);
		vec2 positive_step = (2.0 * vec2(tile + ivec2(1, 1))) / vec2(tile_number);

		frustum_planes[0]  = vec4(1.0, 0.0, 0.0, 1.0 - negative_step.x) * view_projection;
		frustum_planes[0] /= length(frustum_planes[0].xyz);
		frustum_planes[1]  = vec4(-1.0, 0.0, 0.0, -1.0 + positive_step.x) * view_projection;
		frustum_planes[1] /= length(frustum_planes[1].xyz);
		frustum_planes[2]  = vec4(0.0, 1.0, 0.0, 1.0 - negative_step.y) * view_projection;
		frustum_planes[2] /= length(frustum_planes[2].xyz);
		frustum_planes[3]  = vec4(0.0, -1.0, 0.0, -1.0 + positive_step.y) * view_projection;
		frustum_planes[3] /= length(frustum_planes[3].xyz);
		frustum_planes[4]  = vec4(0.0, 0.0, -1.0, -min_depth) * scene_data.view;
		frustum_planes[4] /= length(frustum_planes[4].xyz);
		frustum_planes[5]  = vec4(0.0, 0.0, 1.0, max_depth) * scene_data.view;
		frustum_planes[5] /= length(frustum_planes[5].xyz);
	}

	barrier();

	uint thread_count = TILE_SIZE * TILE_SIZE;
	uint pass_count = (scene_data.light_count + thread_count - 1) / thread_count;

	for (uint i = 0; i < pass_count; ++i) {
		uint light_index = i * thread_count + gl_LocalInvocationIndex;
		if (light_index >= scene_data.light_count || light_buffer.data[light_index].color.a < 0.02)
			break;

		if (uint(light_buffer.data[light_index].position.w) != LT_DIRECTIONAL) {
			float distance = dot(vec4(light_buffer.data[light_index].position.xyz, 1.0), frustum_planes[0]) + light_buffer.data[light_index].data.y;
			if (distance <= 0.0) continue;

			distance = dot(vec4(light_buffer.data[light_index].position.xyz, 1.0), frustum_planes[1]) + light_buffer.data[light_index].data.y;
			if (distance <= 0.0) continue;

			distance = dot(vec4(light_buffer.data[light_index].position.xyz, 1.0), frustum_planes[2]) + light_buffer.data[light_index].data.y;
			if (distance <= 0.0) continue;

			distance = dot(vec4(light_buffer.data[light_index].position.xyz, 1.0), frustum_planes[3]) + light_buffer.data[light_index].data.y;
			if (distance <= 0.0) continue;

			distance = dot(vec4(light_buffer.data[light_index].position.xyz, 1.0), frustum_planes[4]) + light_buffer.data[light_index].data.y;
			if (distance <= 0.0) continue;

			distance = dot(vec4(light_buffer.data[light_index].position.xyz, 1.0), frustum_planes[5]) + light_buffer.data[light_index].data.y;
			if (distance <= 0.0) continue;
		}

		// Directional lights are always visible

		uint offset = atomicAdd(visible_lights, 1);
		visible_indices[offset] = int(light_index);
	}

	barrier();

	if (gl_LocalInvocationIndex == 0) {
		uint offset = index * 1024;
		for(uint i = 0; i < visible_lights; ++i)
			visible_indices_buffer.data[offset + i] = visible_indices[i];

		if (visible_lights != 1024)
			visible_indices_buffer.data[offset + visible_lights] = -1;
	}
}
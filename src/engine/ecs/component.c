/* NekoEngine
 *
 * component.c
 * Author: Alexandru Naiman
 *
 * NekoEngine Component
 *
 * -----------------------------------------------------------------------------
 *
 * Copyright (c) 2015-2019, Alexandru Naiman
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors
 * may be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY ALEXANDRU NAIMAN "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL ALEXANDRU NAIMAN BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <system/log.h>
#include <runtime/runtime.h>

#include <ecs/component.h>
#include <ecs/ecsys_internal.h>

static int64_t _next_handle;
static rt_array _component_types;
static rt_array _component_data;
static rt_array _component_handles;

#define ECSYS_COMP_MODULE	"ECSys_Component"

// This function is generated by ecsgen
ne_status comp_sys_register_all(void);

int
_comp_type_cmp(
	void *item,
	const void *data)
{
	return !(((struct ne_comp_type *)item)->hash == *((uint64_t *)data));
}

int
_comp_handle_cmp(
	const void *item,
	const void *data)
{
	const struct ne_comp_handle *handle = item;
	comp_handle val = *(comp_handle *)data;

	if (handle->handle == val)
		return 0;
	else if (handle->handle > val)
		return 1;
	else
		return -1;
}

static inline struct ne_comp_handle *
_get_handle_ptr(comp_handle comp)
{
	return rt_array_bsearch(&_component_handles, &comp, _comp_handle_cmp);
	//return rt_array_find(&_component_handles, &comp, _comp_handle_cmp);
}

ne_status
comp_sys_init(void)
{
	if (rt_array_init(&_component_types, 40, sizeof(struct ne_comp_type)))
		return NE_FAIL;

	if (rt_array_init(&_component_data, 40, sizeof(rt_array)))
		return NE_FAIL;

	if (rt_array_init(&_component_handles, 1000,
				sizeof(struct ne_comp_handle)))
		return NE_FAIL;

	return comp_sys_register_all();
}

ne_status
comp_sys_register(void)
{
	return NE_OK;
}

void
comp_sys_release(void)
{
	rt_array *a = NULL;
	struct ne_comp_type *type = NULL;

	for (size_t i = 0; i < _component_data.count; ++i) {
		type = rt_array_get(&_component_types, i);
		a = rt_array_get(&_component_data, i);

		if (type->destroy)
			for (size_t j = 0; j < a->count; ++j)
				type->destroy(rt_array_get(a, j));

		rt_array_release(rt_array_get(&_component_data, i));
	}

	rt_array_release(&_component_data);
	rt_array_release(&_component_types);
	rt_array_release(&_component_handles);
}

rt_array *
comp_sys_get_all(comp_type_id type)
{
	if (type >= _component_data.count)
		return NULL;

	return rt_array_get(&_component_data, type);
}

comp_handle
comp_create(
	const char *type_name,
	entity_handle owner,
	const void **args)
{
	comp_type_id id = 0;
	rt_array *a = NULL;
	struct ne_comp_base *comp = NULL;
	struct ne_comp_type *type = NULL;
	struct ne_comp_handle *handle = NULL;

	id = comp_get_type_id(type_name);
	if (id == RT_NOT_FOUND) {
		log_entry(ECSYS_COMP_MODULE, LOG_CRITICAL,
			"Type [%] does not exist", type_name);
		return NE_INVALID_COMPONENT;
	}
	type = rt_array_get(&_component_types, id);

	a = rt_array_get(&_component_data, id);
	if (!a) {
		log_entry(ECSYS_COMP_MODULE, LOG_CRITICAL,
			"Data for type [%s] does not exist", type_name);
		return NE_INVALID_COMPONENT;
	}

	comp = rt_array_create(a);
	if (!comp) {
		log_entry(ECSYS_COMP_MODULE, LOG_CRITICAL,
			"Failed to allocate component of type [%s] ",
			type_name);
		return NE_INVALID_COMPONENT;
	}

	handle = rt_array_create(&_component_handles);
	if (!handle) {
		log_entry(ECSYS_COMP_MODULE, LOG_CRITICAL,
			"Failed to allocate component handle of type [%s] ",
			type_name);
		return NE_INVALID_COMPONENT;
	}

	handle->type = id;
	handle->handle = _next_handle++;
	handle->index = a->count - 1;

	comp->_owner = owner;
	comp->_self = handle;

	if (type->create && (type->create(comp, args) != NE_OK)) {
		--a->count;
		--_next_handle;
		--_component_handles.count;
		log_entry(ECSYS_COMP_MODULE, LOG_CRITICAL,
			"Failed to create component of type [%s] ",
			type_name);
		return NE_INVALID_COMPONENT;
	}

	return handle->handle;
}

comp_handle
comp_create_id(
	comp_type_id id,
	entity_handle owner,
	const void **args)
{
	rt_array *a = NULL;
	struct ne_comp_type *type = NULL;
	struct ne_comp_base *comp = NULL;
	struct ne_comp_handle *handle = NULL;

	type = rt_array_get(&_component_types, id);
	if (!type)
		return -1;

	a = rt_array_get(&_component_data, id);
	if (!a)
		return -1;

	comp = rt_array_create(a);
	if (!comp)
		return -1;

	handle = rt_array_create(&_component_handles);
	if (!handle)
		return NE_INVALID_COMPONENT;

	handle->type = id;
	handle->handle = _next_handle++;
	handle->index = a->count - 1;

	comp->_owner = owner;
	comp->_self = handle;

	if (type->create && (type->create(comp, args) != NE_OK)) {
		--a->count;
		--_next_handle;
		--_component_handles.count;
		return NE_INVALID_COMPONENT;
	}

	return handle->handle;
}

void
comp_destroy(comp_handle comp)
{
	struct ne_comp_handle *handle = NULL;
	struct ne_comp_type *type = NULL;
	uint8_t *dst = NULL, *src = NULL;
	size_t dst_index = 0;
	rt_array *a = NULL;

	handle = _get_handle_ptr(comp);
	if (!handle)
		return;

	type = rt_array_get(&_component_types, handle->type);
	if (!type)
		return;

	a = rt_array_get(&_component_data, handle->type);
	if (!a)
		return;

	dst_index = handle->index;

	src = rt_array_last(a);
	dst = rt_array_get(a, dst_index);

	if (type->destroy)
		type->destroy(dst);

	memcpy(dst, src, a->elem_size);

	handle = ((struct ne_comp_base *)dst)->_self;
	handle->index = dst_index;

	--a->count;
}

void *
comp_ptr(comp_handle comp)
{
	rt_array *a = NULL;
	struct ne_comp_handle *handle = NULL;

	handle = _get_handle_ptr(comp);
	if (!handle)
		return NULL;

	a = rt_array_get(&_component_data, handle->type);
	if (!a)
		return NULL;

	return rt_array_get(a, handle->index);
}

comp_type_id
comp_get_type_id(const char *type_name)
{
	uint64_t hash = 0;
	hash = rt_hash_string(type_name);
	return rt_array_find_id(&_component_types, &hash, _comp_type_cmp);
}

size_t
comp_get_count(comp_type_id type)
{
	return ((rt_array *)rt_array_get(&_component_data, type))->count;
}

comp_type_id
comp_get_type(comp_handle comp)
{
	struct ne_comp_handle *handle = NULL;

	handle = _get_handle_ptr(comp);
	if (!handle)
		return NE_INVALID_COMPONENT_TYPE;

	return handle->type;
}

entity_handle
comp_get_owner(comp_handle comp)
{
	struct ne_comp_base *ptr = comp_ptr(comp);
	return ptr ? ptr->_owner : NE_INVALID_ENTITY;
}

void
comp_set_owner(
	comp_handle comp,
	entity_handle owner)
{
	struct ne_comp_base *ptr = comp_ptr(comp);
	if (!ptr)
		return;
	ptr->_owner = owner;
}

ne_status
comp_register(
	const char *name,
	size_t size,
	comp_init_proc create,
	comp_release_proc destroy)
{
	rt_array data;
	struct ne_comp_type type;

	type.size = size;
	type.hash = rt_hash_string(name);
	type.create = create;
	type.destroy = destroy;

	if (size < sizeof(struct ne_comp_base))
		return NE_INVALID_ARGS;

	if (rt_array_find_id(&_component_types, &type.hash, _comp_type_cmp)
		!= RT_NOT_FOUND)
		return NE_ALREADY_EXISTS;

	if (rt_array_init(&data, 10, size))
		return NE_FAIL;

	if (rt_array_add(&_component_data, &data)) {
		rt_array_release(&data);
		return NE_FAIL;
	}

	if (rt_array_add(&_component_types, &type)) {
		rt_array_remove(&_component_data, _component_data.count - 1);
		rt_array_release(&data);
		return NE_FAIL;
	}

	return NE_OK;
}

